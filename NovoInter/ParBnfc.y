-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParBnfc
  ( happyError
  , myLexer
  , pProgram
  , pListStmt
  , pStmt
  , pExpr
  , pTerm
  , pFactor
  ) where

import Prelude

import qualified AbsBnfc
import LexBnfc

}

%name pProgram Program
%name pListStmt ListStmt
%name pStmt Stmt
%name pExpr Expr
%name pTerm Term
%name pFactor Factor
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('      { PT _ (TS _ 1)   }
  ')'      { PT _ (TS _ 2)   }
  '*'      { PT _ (TS _ 3)   }
  '+'      { PT _ (TS _ 4)   }
  '-'      { PT _ (TS _ 5)   }
  '/'      { PT _ (TS _ 6)   }
  '='      { PT _ (TS _ 7)   }
  'print'  { PT _ (TS _ 8)   }
  L_integ  { PT _ (TI $$)    }
  L_integ  { PT _ (TI $$)    }
  L_Var    { PT _ (T_Var $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Var :: { AbsBnfc.Var }
Var  : L_Var { AbsBnfc.Var $1 }

Program :: { AbsBnfc.Program }
Program : ListStmt { AbsBnfc.Prog $1 }

ListStmt :: { [AbsBnfc.Stmt] }
ListStmt : {- empty -} { [] } | Stmt ListStmt { (:) $1 $2 }

Stmt :: { AbsBnfc.Stmt }
Stmt
  : Var '=' Expr { AbsBnfc.Assign $1 $3 }
  | 'print' Expr { AbsBnfc.Print $2 }

Expr :: { AbsBnfc.Expr }
Expr
  : Expr '+' Term { AbsBnfc.EAdd $1 $3 }
  | Expr '-' Term { AbsBnfc.ESub $1 $3 }
  | Term { AbsBnfc.ESimp $1 }

Term :: { AbsBnfc.Term }
Term
  : Term '*' Factor { AbsBnfc.TMul $1 $3 }
  | Term '/' Factor { AbsBnfc.TDiv $1 $3 }
  | Factor { AbsBnfc.TSimp $1 }

Factor :: { AbsBnfc.Factor }
Factor
  : Integer { AbsBnfc.FInt $1 }
  | Var { AbsBnfc.FVar $1 }
  | '(' Expr ')' { AbsBnfc.FPar $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}


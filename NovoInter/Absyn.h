/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* StringInteger;
typedef char* Ident;
typedef char* String;

/********************   Forward Declarations    ***********************/
struct Expr_;
typedef struct Expr_ *Expr;

struct Term_;
typedef struct Term_ *Term;

struct Factor_;
typedef struct Factor_ *Factor;

struct Stm_;
typedef struct Stm_ *Stm;

/********************   Abstract Syntax Classes    ********************/

struct Expr_
{
  enum { is_EAdd, is_ESub } kind;
  union
  {
    struct { Expr expr_; Term term_; } eadd_;
    struct { Expr expr_; Term term_; } esub_;
  } u;
};

Expr make_EAdd(Expr p0, Term p1);
Expr make_ESub(Expr p0, Term p1);

struct Term_
{
  enum { is_TMul, is_TDiv, is_TExpr } kind;
  union
  {
    struct { Factor factor_; Term term_; } tmul_;
    struct { Factor factor_; Term term_; } tdiv_;
    struct { Factor factor_; } texpr_;
  } u;
};

Term make_TMul(Term p0, Factor p1);
Term make_TDiv(Term p0, Factor p1);
Term make_TExpr(Factor p0);

struct Factor_
{
  enum { is_FInt, is_FVar, is_FStr, is_FPar, is_FIndex } kind;
  union
  {
    struct { Integer integer_; } fint_;
    struct { Ident ident_; } fvar_;
    struct { String string_; } fstr_;
    struct { Expr expr_; } fpar_;
    struct { Expr expr_; Ident ident_; } findex_;
  } u;
};

Factor make_FInt(Integer p0);
Factor make_FVar(Ident p0);
Factor make_FStr(String p0);
Factor make_FPar(Expr p0);
Factor make_FIndex(Ident p0, Expr p1);

struct Stm_
{
  enum { is_Assign, is_ArrAssign, is_Print } kind;
  union
  {
    struct { Expr expr_; Ident ident_; } assign_;
    struct { Expr expr_1, expr_2; Ident ident_; } arrassign_;
    struct { Expr expr_; } print_;
  } u;
};

Stm make_Assign(Ident p0, Expr p1);
Stm make_ArrAssign(Ident p0, Expr p1, Expr p2);
Stm make_Print(Expr p0);

/***************************   Cloning   ******************************/

Expr clone_Expr(Expr p);
Term clone_Term(Term p);
Factor clone_Factor(Factor p);
Stm clone_Stm(Stm p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Expr(Expr p);
void free_Term(Term p);
void free_Factor(Factor p);
void free_Stm(Stm p);


#endif

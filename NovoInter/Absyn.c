
/* File generated by the BNF Converter (bnfc 2.9.5). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"
#include <string.h> 

/********************   EAdd    ********************/

Expr make_EAdd(Expr p1, Term p2)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EAdd!\n");
        exit(1);
    }
    tmp->kind = is_EAdd;
    tmp->u.eadd_.expr_ = p1;
    tmp->u.eadd_.term_ = p2;
    return tmp;
}

/********************   ESub    ********************/

Expr make_ESub(Expr p1, Term p2)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ESub!\n");
        exit(1);
    }
    tmp->kind = is_ESub;
    tmp->u.esub_.expr_ = p1;
    tmp->u.esub_.term_ = p2;
    return tmp;
}

/********************   TMul    ********************/

Term make_TMul(Term p1, Factor p2)
{
    Term tmp = (Term) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TMul!\n");
        exit(1);
    }
    tmp->kind = is_TMul;
    tmp->u.tmul_.term_ = p1;
    tmp->u.tmul_.factor_ = p2;
    return tmp;
}

/********************   TDiv    ********************/

Term make_TDiv(Term p1, Factor p2)
{
    Term tmp = (Term) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TDiv!\n");
        exit(1);
    }
    tmp->kind = is_TDiv;
    tmp->u.tdiv_.term_ = p1;
    tmp->u.tdiv_.factor_ = p2;
    return tmp;
}

/********************   TExpr    ********************/

Term make_TExpr(Factor p1)
{
    Term tmp = (Term) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TExpr!\n");
        exit(1);
    }
    tmp->kind = is_TExpr;
    tmp->u.texpr_.factor_ = p1;
    return tmp;
}

/********************   FInt    ********************/

Factor make_FInt(Integer p1)
{
    Factor tmp = (Factor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FInt!\n");
        exit(1);
    }
    tmp->kind = is_FInt;
    tmp->u.fint_.integer_ = p1;
    return tmp;
}

/********************   FVar    ********************/

Factor make_FVar(Ident p1)
{
    Factor tmp = (Factor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FVar!\n");
        exit(1);
    }
    tmp->kind = is_FVar;
    tmp->u.fvar_.ident_ = p1;
    return tmp;
}

/********************   FStr    ********************/

Factor make_FStr(String p1)
{
    Factor tmp = (Factor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FStr!\n");
        exit(1);
    }
    tmp->kind = is_FStr;
    tmp->u.fstr_.string_ = p1;
    return tmp;
}

/********************   FPar    ********************/

Factor make_FPar(Expr p1)
{
    Factor tmp = (Factor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FPar!\n");
        exit(1);
    }
    tmp->kind = is_FPar;
    tmp->u.fpar_.expr_ = p1;
    return tmp;
}

/********************   FIndex    ********************/

Factor make_FIndex(Ident p1, Expr p2)
{
    Factor tmp = (Factor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FIndex!\n");
        exit(1);
    }
    tmp->kind = is_FIndex;
    tmp->u.findex_.ident_ = p1;
    tmp->u.findex_.expr_ = p2;
    return tmp;
}

/********************   Assign    ********************/

Stm make_Assign(Ident p1, Expr p2)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Assign!\n");
        exit(1);
    }
    tmp->kind = is_Assign;
    tmp->u.assign_.ident_ = p1;
    tmp->u.assign_.expr_ = p2;
    return tmp;
}

/********************   ArrAssign    ********************/

Stm make_ArrAssign(Ident p1, Expr p2, Expr p3)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ArrAssign!\n");
        exit(1);
    }
    tmp->kind = is_ArrAssign;
    tmp->u.arrassign_.ident_ = p1;
    tmp->u.arrassign_.expr_1 = p2;
    tmp->u.arrassign_.expr_2 = p3;
    return tmp;
}

/********************   Print    ********************/

Stm make_Print(Expr p1)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Print!\n");
        exit(1);
    }
    tmp->kind = is_Print;
    tmp->u.print_.expr_ = p1;
    return tmp;
}

/***************************   Cloning   ******************************/

Expr clone_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_EAdd:
    return make_EAdd
      ( clone_Expr(p->u.eadd_.expr_)
      , clone_Term(p->u.eadd_.term_)
      );

  case is_ESub:
    return make_ESub
      ( clone_Expr(p->u.esub_.expr_)
      , clone_Term(p->u.esub_.term_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Expr!\n");
    exit(1);
  }
}

Term clone_Term(Term p)
{
  switch(p->kind)
  {
  case is_TMul:
    return make_TMul
      ( clone_Term(p->u.tmul_.term_)
      , clone_Factor(p->u.tmul_.factor_)
      );

  case is_TDiv:
    return make_TDiv
      ( clone_Term(p->u.tdiv_.term_)
      , clone_Factor(p->u.tdiv_.factor_)
      );

  case is_TExpr:
    return make_TExpr (clone_Factor(p->u.texpr_.factor_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Term!\n");
    exit(1);
  }
}

Factor clone_Factor(Factor p)
{
  switch(p->kind)
  {
  case is_FInt:
    return make_FInt (p->u.fint_.integer_);

  case is_FVar:
    return make_FVar (strdup(p->u.fvar_.ident_));

  case is_FStr:
    return make_FStr (strdup(p->u.fstr_.string_));

  case is_FPar:
    return make_FPar (clone_Expr(p->u.fpar_.expr_));

  case is_FIndex:
    return make_FIndex
      ( strdup(p->u.findex_.ident_)
      , clone_Expr(p->u.findex_.expr_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Factor!\n");
    exit(1);
  }
}

Stm clone_Stm(Stm p)
{
  switch(p->kind)
  {
  case is_Assign:
    return make_Assign
      ( strdup(p->u.assign_.ident_)
      , clone_Expr(p->u.assign_.expr_)
      );

  case is_ArrAssign:
    return make_ArrAssign
      ( strdup(p->u.arrassign_.ident_)
      , clone_Expr(p->u.arrassign_.expr_1)
      , clone_Expr(p->u.arrassign_.expr_2)
      );

  case is_Print:
    return make_Print (clone_Expr(p->u.print_.expr_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Stm!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_EAdd:
    free_Expr(p->u.eadd_.expr_);
    free_Term(p->u.eadd_.term_);
    break;

  case is_ESub:
    free_Expr(p->u.esub_.expr_);
    free_Term(p->u.esub_.term_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Expr!\n");
    exit(1);
  }
  free(p);
}

void free_Term(Term p)
{
  switch(p->kind)
  {
  case is_TMul:
    free_Term(p->u.tmul_.term_);
    free_Factor(p->u.tmul_.factor_);
    break;

  case is_TDiv:
    free_Term(p->u.tdiv_.term_);
    free_Factor(p->u.tdiv_.factor_);
    break;

  case is_TExpr:
    free_Factor(p->u.texpr_.factor_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Term!\n");
    exit(1);
  }
  free(p);
}

void free_Factor(Factor p)
{
  switch(p->kind)
  {
  case is_FInt:
    break;

  case is_FVar:
    free(p->u.fvar_.ident_);
    break;

  case is_FStr:
    free(p->u.fstr_.string_);
    break;

  case is_FPar:
    free_Expr(p->u.fpar_.expr_);
    break;

  case is_FIndex:
    free(p->u.findex_.ident_);
    free_Expr(p->u.findex_.expr_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Factor!\n");
    exit(1);
  }
  free(p);
}

void free_Stm(Stm p)
{
  switch(p->kind)
  {
  case is_Assign:
    free(p->u.assign_.ident_);
    free_Expr(p->u.assign_.expr_);
    break;

  case is_ArrAssign:
    free(p->u.arrassign_.ident_);
    free_Expr(p->u.arrassign_.expr_1);
    free_Expr(p->u.arrassign_.expr_2);
    break;

  case is_Print:
    free_Expr(p->u.print_.expr_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Stm!\n");
    exit(1);
  }
  free(p);
}

